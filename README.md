# Data Structures & Algorithms

## Create all the data structures from zero

These are building blocks. Implement them manually without built-in types
like list or dict unless needed.

- Array â€“ Implement dynamic array behavior (like Python list)
- Singly Linked List â€“ append, prepend, delete, find
- Doubly Linked List
- Stack â€“ Using array and linked list
- Queue â€“ Using array and linked list
- Circular Queue
- Hash Map â€“ With linear probing or chaining
- Set â€“ Based on hash map
- Binary Tree â€“ Insert, search, DFS, BFS
- Binary Search Tree (BST) â€“ Insert, delete, find, traversals
- Tries â€“ Insert, search, prefix search
- Heap â€“ Min-heap & Max-heap (binary heap)
- Graph (Adjacency List / Matrix) â€“ Undirected & Directed

Implement Algorithms Using Your Structures

Use your data structures to write algorithms manually.

**Searching & Sorting**

- Linear Search
- Binary Search
- Bubble Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Heap Sort
- Radix Sort (optional)

**Tree Algorithms**

- Inorder, Preorder, Postorder Traversals (recursive & iterative)
- Level Order (BFS)
- Lowest Common Ancestor (BST and general tree)
- Diameter of a Tree
- Balanced Tree Check
- **Graph Algorithms**
- DFS
- BFS
- Detect Cycle (DFS, Union Find)
- Topological Sort
- Dijkstraâ€™s Algorithm
- Kruskalâ€™s Algorithm (MST)
- Bellman-Ford

**Dynamic Programming**
Start with memoization (top-down), then tabulation (bottom-up).

- Fibonacci (recursive, memo, tabulation)
- Climbing Stairs
- Coin Change
- Knapsack (0/1)
- Longest Increasing Subsequence
- Longest Common Subsequence

**Greedy Algorithms**

- Activity Selection
- Gas Station
- Jump Game
- Interval Scheduling
- ðŸ§® Math & Bit Manipulation
- GCD/LCM (Euclidean Algorithm)
- Sieve of Eratosthenes
- Bitwise AND, OR, XOR, NOT
- Count set bits
- Find single number with XOR

## General view of all topics in Neetcode

1. Arrays & Hashing

Two Pointers
Sliding Window
Prefix Sum
HashMap / HashSet
Frequency Counters

2. Two Pointers

Left and Right Pointer
Fast and Slow Pointer (for cycle detection)

3. Sliding Window

Fixed-length window
Variable-length window (e.g., longest substring)

4. Stack

Monotonic Stack
Valid Parentheses
Next Greater Element
Infix â†’ Postfix (basic stack operations)

5. Binary Search

Basic Binary Search
Search in Rotated Sorted Array
Binary Search on Answer (e.g., min/max search in a range)

6. Linked List

Reverse Linked List
Merge Two Lists
Detect Cycle
Middle of the List
Remove Nth Node

7. Trees

DFS (Depth First Search)
BFS (Breadth First Search)
Binary Tree vs Binary Search Tree (BST)
Lowest Common Ancestor
Tree Traversals: Preorder, Inorder, Postorder

8. Tries

Implement Trie
Prefix search
Word Dictionary

9. Heap / Priority Queue

Min Heap, Max Heap
Kth Largest Element
Merge K Sorted Lists

10. Backtracking

Subsets / Permutations
N-Queens
Sudoku Solver

11. Graph

DFS / BFS
Union Find (Disjoint Set)
Topological Sort
Detect Cycles in Graph
Dijkstraâ€™s Algorithm (sometimes)

12. Advanced Graphs

Bellman-Ford
Floyd-Warshall
Minimum Spanning Tree (Kruskalâ€™s / Primâ€™s)

13. 1D & 2D Dynamic Programming (DP)

Fibonacci, Climbing Stairs
Knapsack
Longest Increasing Subsequence
Coin Change
Grid DP (unique paths, obstacles)

14. Greedy Algorithms

Activity Selection
Gas Station
Jump Game

15. Intervals

Merge Intervals
Insert Interval
Non-overlapping Intervals
Meeting Rooms

16. Math & Geometry

Sieve of Eratosthenes
GCD/LCM
Bit Manipulation
Prime checking
Modular Arithmetic

17. Bit Manipulation

XOR tricks
Single Number
Bitmasking

## Bonus: System Design (after DSA mastery)

Once youâ€™re comfortable with DSA, you can move to:

Database Design
Caching
Load Balancing
Sharding
Queues and Pub/Sub
